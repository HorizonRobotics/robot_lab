frame_transform
===============

.. py:module:: robo_orchard_lab.dataset.experimental.mcap.msg_converter.frame_transform


Classes
-------

.. autoapisummary::

   robo_orchard_lab.dataset.experimental.mcap.msg_converter.frame_transform.BatchFrameTransformStamped
   robo_orchard_lab.dataset.experimental.mcap.msg_converter.frame_transform.ToBatchFrameTransformStamped
   robo_orchard_lab.dataset.experimental.mcap.msg_converter.frame_transform.ToBatchFrameTransformStampedConfig


Module Contents
---------------

.. py:class:: BatchFrameTransformStamped(/, **data: Any)

   Bases: :py:obj:`robo_orchard_core.datatypes.camera_data.BatchFrameTransform`


   A batch of transformations between two coordinate frames in 3D space.

   A transformation must specify the parent and child frames it connects,
   and all sample should share the same parent and child frames.


   .. py:attribute:: timestamps
      :type:  list[pydantic.SkipValidation[google.protobuf.timestamp_pb2.Timestamp] | None] | None
      :value: None


      Timestamp for the frame transform


   .. py:method:: repeat(batch_size: int, timestamps: list[google.protobuf.timestamp_pb2.Timestamp | None] | None) -> robo_orchard_core.datatypes.camera_data.BatchFrameTransform

      Repeat the transformation to create a batch of transformations.

      :param batch_size: The number of times to repeat the transformation.
      :type batch_size: int

      :returns:

                A batch of transformations with the same
                    parent and child frames.
      :rtype: BatchFrameTransform



   .. py:attribute:: parent_frame_id
      :type:  str

      The coordinate frame ID of the parent frame.


   .. py:attribute:: child_frame_id
      :type:  str

      The coordinate frame ID of the child frame.


   .. py:method:: compose(*others: typing_extensions.Self) -> typing_extensions.Self

      Compose transformations with other transformations.

      The transformations are applied in the order they are passed.
      The following two lines are equivalent:

      .. code-block:: python

          t = t1.compose(t2, t3)
          t = t1.compose(t2).compose(t3)

      :param other: The other batch of transformations.
      :type other: Self

      :returns:

                A new object with the
                    composed transformations.
      :rtype: Self



   .. py:attribute:: xyz
      :type:  robo_orchard_core.utils.config.TorchTensor
      :value: None


      3D Translation or points. Shape is (N, 3) where N is the batch size.


   .. py:attribute:: quat
      :type:  robo_orchard_core.utils.config.TorchTensor
      :value: None


      Quaternion rotation/orientation (w, x, y, z).

      Shape is (N, 4) where N is the batch size.


   .. py:method:: identity(batch_size: int, device: robo_orchard_core.utils.torch_utils.Device = 'cpu') -> typing_extensions.Self
      :classmethod:


      Get a batch of identity transformations.

      :param batch_size: The batch size.
      :type batch_size: int
      :param device: The device to put the tensors on.
      :type device: Device

      :returns: A batch of identity transformations.
      :rtype: BatchTransform3D



   .. py:method:: from_view(position: robo_orchard_core.utils.config.TorchTensor, look_at: robo_orchard_core.utils.config.TorchTensor, device: robo_orchard_core.utils.torch_utils.Device = 'cpu', view_convention: robo_orchard_core.utils.math.CoordConventionType = 'world') -> typing_extensions.Self
      :classmethod:


      Create a batch of transformations from view.

      :param position: The position of the camera in local frame.
      :type position: TorchTensor
      :param look_at: The target to look at in local frame.
      :type look_at: TorchTensor
      :param view_convention: The view convention to
                              apply.
      :type view_convention: CoordConventionType

      :returns: A batch of transformations.
      :rtype: BatchTransform3D



   .. py:property:: rot
      :type: torch.Tensor



   .. py:property:: trans
      :type: torch.Tensor



   .. py:property:: batch_size
      :type: int


      Get the batch size.

      The batch size is the number of poses/transforms in the batch.

      :returns: The batch size.
      :rtype: int


   .. py:method:: check_shape()

      Check the shape of the translation and rotation tensors.

      :raises ValueError: If the shapes of the translation and rotation tensors
          are not valid.



   .. py:method:: as_Transform3D_M() -> robo_orchard_core.utils.math.transform.transform3d.Transform3D_M

      Convert the BatchTransform3D to matrix form.

      :returns: A batch of Transform3D_M objects.
      :rtype: Transform3D_M



   .. py:method:: transform_points(points: torch.Tensor) -> torch.Tensor

      Transform a batch of points by the batch of transformations.

      :param points: A tensor of shape (N, P, 3) representing
                     the batch of points to transform.
      :type points: torch.Tensor

      :returns:

                A tensor of shape (N, P, 3) representing
                    the transformed points.
      :rtype: torch.Tensor



   .. py:method:: subtract(other: typing_extensions.Self) -> typing_extensions.Self

      Subtract transformations with another.

      .. code-block:: python

          t = t2.subtract(t1)
          t_ = t2.compose(t1.inverse())
          t == t_

          t2_ = t.compose(t1)
          t2 == t2_

      :param other: The other transformation.
      :type other: Self

      :returns: The difference between the two transformations.
      :rtype: Self



   .. py:method:: inverse() -> typing_extensions.Self

      Get the inverse of the transformations.

      :returns: A new object with the inverse transformations.
      :rtype: Self



   .. py:method:: translate(translation: robo_orchard_core.utils.config.TorchTensor) -> typing_extensions.Self

      Apply translation to the transformations.

      :param translation: The translation to apply to.
                          Shape should be (3,) or (N, 3) where N is the batch size.
      :type translation: TorchTensor



   .. py:method:: rotate(axis_angle: robo_orchard_core.utils.config.TorchTensor) -> typing_extensions.Self

      Rotate the transformations by an axis-angle rotation.

      :param axis_angle: The axis-angle rotation to apply to.
                         Shape should be (3,) or (N, 3) where N is the batch size.
      :type axis_angle: TorchTensor



   .. py:attribute:: model_config

      Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].


   .. py:method:: model_post_init(*args, **kwargs)

      Post init method for the model.

      Perform additional initialization after :py:meth:`__init__`
      and model_construct. This is useful if you want to do some validation
      that requires the entire model to be initialized.

      To be consistent with configclass, this method is implemented by
      calling the :py:meth:`__post_init__` method.




   .. py:attribute:: model_fields
      :type:  ClassVar[dict[str, pydantic.fields.FieldInfo]]


   .. py:property:: model_extra
      :type: dict[str, Any] | None


      Get extra fields set during validation.

      :returns: A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.


   .. py:property:: model_fields_set
      :type: set[str]


      Returns the set of fields that have been explicitly set on this model instance.

      :returns:

                A set of strings representing the fields that have been set,
                    i.e. that were not filled from defaults.


   .. py:method:: model_construct(_fields_set: set[str] | None = None, **values: Any) -> typing_extensions.Self
      :classmethod:


      Creates a new instance of the `Model` class with validated data.

      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
      Default values are respected, but no other validation is performed.

      !!! note
          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
          an error if extra values are passed, but they will be ignored.

      :param _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
                          this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
                          Otherwise, the field names from the `values` argument will be used.
      :param values: Trusted or pre-validated data dictionary.

      :returns: A new instance of the `Model` class with validated data.



   .. py:method:: model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -> typing_extensions.Self

      Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy

      Returns a copy of the model.

      :param update: Values to change/add in the new model. Note: the data is not validated
                     before creating the new model. You should trust this data.
      :param deep: Set to `True` to make a deep copy of the model.

      :returns: New model instance.



   .. py:method:: model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> dict[str, Any]

      Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump

      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.

      :param mode: The mode in which `to_python` should run.
                   If mode is 'json', the output will only contain JSON serializable types.
                   If mode is 'python', the output may contain non-JSON-serializable Python objects.
      :param include: A set of fields to include in the output.
      :param exclude: A set of fields to exclude from the output.
      :param context: Additional context to pass to the serializer.
      :param by_alias: Whether to use the field's alias in the dictionary key if defined.
      :param exclude_unset: Whether to exclude fields that have not been explicitly set.
      :param exclude_defaults: Whether to exclude fields that are set to their default value.
      :param exclude_none: Whether to exclude fields that have a value of `None`.
      :param round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
      :param warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
                       "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
      :param serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.

      :returns: A dictionary representation of the model.



   .. py:method:: model_dump_json(*, indent: int | None = None, include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> str

      Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json

      Generates a JSON representation of the model using Pydantic's `to_json` method.

      :param indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
      :param include: Field(s) to include in the JSON output.
      :param exclude: Field(s) to exclude from the JSON output.
      :param context: Additional context to pass to the serializer.
      :param by_alias: Whether to serialize using field aliases.
      :param exclude_unset: Whether to exclude fields that have not been explicitly set.
      :param exclude_defaults: Whether to exclude fields that are set to their default value.
      :param exclude_none: Whether to exclude fields that have a value of `None`.
      :param round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
      :param warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
                       "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
      :param serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.

      :returns: A JSON string representation of the model.



   .. py:method:: model_json_schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, schema_generator: type[pydantic.json_schema.GenerateJsonSchema] = GenerateJsonSchema, mode: pydantic.json_schema.JsonSchemaMode = 'validation') -> dict[str, Any]
      :classmethod:


      Generates a JSON schema for a model class.

      :param by_alias: Whether to use attribute aliases or not.
      :param ref_template: The reference template.
      :param schema_generator: To override the logic used to generate the JSON schema, as a subclass of
                               `GenerateJsonSchema` with your desired modifications
      :param mode: The mode in which to generate the schema.

      :returns: The JSON schema for the given model class.



   .. py:method:: model_parametrized_name(params: tuple[type[Any], Ellipsis]) -> str
      :classmethod:


      Compute the class name for parametrizations of generic classes.

      This method can be overridden to achieve a custom naming scheme for generic BaseModels.

      :param params: Tuple of types of the class. Given a generic class
                     `Model` with 2 type variables and a concrete model `Model[str, int]`,
                     the value `(str, int)` would be passed to `params`.

      :returns: String representing the new class where `params` are passed to `cls` as type variables.

      :raises TypeError: Raised when trying to generate concrete names for non-generic models.



   .. py:method:: model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: pydantic._internal._namespace_utils.MappingNamespace | None = None) -> bool | None
      :classmethod:


      Try to rebuild the pydantic-core schema for the model.

      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
      the initial attempt to build the schema, and automatic rebuilding fails.

      :param force: Whether to force the rebuilding of the model schema, defaults to `False`.
      :param raise_errors: Whether to raise errors, defaults to `True`.
      :param _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
      :param _types_namespace: The types namespace, defaults to `None`.

      :returns: Returns `None` if the schema is already "complete" and rebuilding was not required.
                If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.



   .. py:method:: model_validate(obj: Any, *, strict: bool | None = None, from_attributes: bool | None = None, context: Any | None = None) -> typing_extensions.Self
      :classmethod:


      Validate a pydantic model instance.

      :param obj: The object to validate.
      :param strict: Whether to enforce types strictly.
      :param from_attributes: Whether to extract data from object attributes.
      :param context: Additional context to pass to the validator.

      :raises ValidationError: If the object could not be validated.

      :returns: The validated model instance.



   .. py:method:: model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, context: Any | None = None) -> typing_extensions.Self
      :classmethod:


      Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing

      Validate the given JSON data against the Pydantic model.

      :param json_data: The JSON data to validate.
      :param strict: Whether to enforce types strictly.
      :param context: Extra variables to pass to the validator.

      :returns: The validated Pydantic model.

      :raises ValidationError: If `json_data` is not a JSON string or the object could not be validated.



   .. py:method:: model_validate_strings(obj: Any, *, strict: bool | None = None, context: Any | None = None) -> typing_extensions.Self
      :classmethod:


      Validate the given object with string data against the Pydantic model.

      :param obj: The object containing string data to validate.
      :param strict: Whether to enforce types strictly.
      :param context: Extra variables to pass to the validator.

      :returns: The validated Pydantic model.



   .. py:method:: dict(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -> Dict[str, Any]


   .. py:method:: json(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -> str


   .. py:method:: parse_obj(obj: Any) -> typing_extensions.Self
      :classmethod:



   .. py:method:: parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: pydantic.deprecated.parse.Protocol | None = None, allow_pickle: bool = False) -> typing_extensions.Self
      :classmethod:



   .. py:method:: parse_file(path: str | pathlib.Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: pydantic.deprecated.parse.Protocol | None = None, allow_pickle: bool = False) -> typing_extensions.Self
      :classmethod:



   .. py:method:: from_orm(obj: Any) -> typing_extensions.Self
      :classmethod:



   .. py:method:: construct(_fields_set: set[str] | None = None, **values: Any) -> typing_extensions.Self
      :classmethod:



   .. py:method:: copy(*, include: pydantic._internal._utils.AbstractSetIntStr | pydantic._internal._utils.MappingIntStrAny | None = None, exclude: pydantic._internal._utils.AbstractSetIntStr | pydantic._internal._utils.MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -> typing_extensions.Self

      Returns a copy of the model.

      !!! warning "Deprecated"
          This method is now deprecated; use `model_copy` instead.

      If you need `include` or `exclude`, use:

      ```python {test="skip" lint="skip"}
      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
      data = {**data, **(update or {})}
      copied = self.model_validate(data)
      ```

      :param include: Optional set or mapping specifying which fields to include in the copied model.
      :param exclude: Optional set or mapping specifying which fields to exclude in the copied model.
      :param update: Optional dictionary of field-value pairs to override field values in the copied model.
      :param deep: If True, the values of fields that are Pydantic models will be deep-copied.

      :returns: A copy of the model with included, excluded and updated fields as specified.



   .. py:method:: schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE) -> Dict[str, Any]
      :classmethod:



   .. py:method:: schema_json(*, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any) -> str
      :classmethod:



   .. py:method:: validate(value: Any) -> typing_extensions.Self
      :classmethod:



   .. py:method:: update_forward_refs(**localns: Any) -> None
      :classmethod:



   .. py:method:: to(device: robo_orchard_core.utils.torch_utils.Device, dtype: torch.dtype | None = None, non_blocking: bool = False) -> typing_extensions.Self

      Move or cast the tensors/modules in the data class.

      This method performs in-place conversion of all tensors and modules
      in the data class to the specified device and dtype.

      :param device: The target device to move the tensors/modules to.
      :type device: Device
      :param dtype: The target dtype to cast
                    the tensors to. If None, the dtype will not be changed.
      :type dtype: torch.dtype | None, optional
      :param non_blocking: If True, the operation will be
                           performed in a non-blocking manner. Defaults to False.
      :type non_blocking: bool, optional



.. py:class:: ToBatchFrameTransformStamped(cfg: ToBatchFrameTransformStampedConfig)

   Bases: :py:obj:`robo_orchard_lab.dataset.experimental.mcap.msg_converter.base.MessageConverterStateless`\ [\ :py:obj:`foxglove_schemas_protobuf.FrameTransform_pb2.FrameTransform | list`\ [\ :py:obj:`foxglove_schemas_protobuf.FrameTransform_pb2.FrameTransform`\ ]\ , :py:obj:`BatchFrameTransformStamped`\ ]


   Convert a Foxglove FrameTransform message to a FrameTransform Type.


   .. py:method:: convert(src: foxglove_schemas_protobuf.FrameTransform_pb2.FrameTransform | list[foxglove_schemas_protobuf.FrameTransform_pb2.FrameTransform]) -> BatchFrameTransformStamped

      Convert the message from one format to another.



   .. py:property:: stateless
      :type: bool


      Return True if the message converter is stateless.

      A message converter is stateless if it does not depend on any
      external state. For example, a message converter that converts a
      protobuf message to a json message is stateless.


   .. py:attribute:: source_type
      :type:  type[S]

      The source type of the adaptor to take as input.


   .. py:attribute:: target_type
      :type:  type[T]

      The target type of the adaptor as output.


   .. py:attribute:: InitFromConfig
      :type:  bool
      :value: True



.. py:class:: ToBatchFrameTransformStampedConfig

   Bases: :py:obj:`robo_orchard_lab.dataset.experimental.mcap.msg_converter.base.MessageConverterConfig`\ [\ :py:obj:`ToBatchFrameTransformStamped`\ ], :py:obj:`robo_orchard_lab.dataset.experimental.mcap.msg_converter.base.TensorTargetConfigMixin`\ [\ :py:obj:`ToBatchFrameTransformStamped`\ ]


   .. py:attribute:: class_type
      :type:  type[ToBatchFrameTransformStamped]


