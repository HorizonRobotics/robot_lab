joint_state
===========

.. py:module:: robo_orchard_lab.dataset.experimental.mcap.msg_converter.joint_state


Attributes
----------

.. autoapisummary::

   robo_orchard_lab.dataset.experimental.mcap.msg_converter.joint_state.ToBatchJointsState_SRC_TYPE


Classes
-------

.. autoapisummary::

   robo_orchard_lab.dataset.experimental.mcap.msg_converter.joint_state.BatchJointsStateStamped
   robo_orchard_lab.dataset.experimental.mcap.msg_converter.joint_state.ToBatchJointsState
   robo_orchard_lab.dataset.experimental.mcap.msg_converter.joint_state.ToBatchJointsStateConfig


Module Contents
---------------

.. py:class:: BatchJointsStateStamped(/, **data: Any)

   Bases: :py:obj:`robo_orchard_core.datatypes.joint_state.BatchJointsState`


   The base data class that extends pydantic's BaseModel.

   This class is used to define data classes that are used to store data
   and validate the data. It extends pydantic's BaseModel and adds a
   :py:meth:`__post_init__` method that can be used to perform additional
   initialization after the model is constructed.

   .. note::

      Serialization and deserialization using pydantic's methods are not
      recommended for performance reasons, as data classes can be used to
      store large tensors or other data that are not easily serialized.
      
      User should implement the proper serialization and deserialization
      methods when needed.


   .. py:attribute:: timestamps
      :type:  list[pydantic.SkipValidation[google.protobuf.timestamp_pb2.Timestamp] | None] | None
      :value: None


      Timestamp for the joint states


   .. py:attribute:: position
      :type:  robo_orchard_core.utils.config.TorchTensor | None
      :value: None


      The position of the joint in radians or meters.

      It should be a tensor of shape (N, D), where D is the number of joints and
      N is the batch size.


   .. py:attribute:: velocity
      :type:  robo_orchard_core.utils.config.TorchTensor | None
      :value: None


      The velocity of the joint in radians or meters per second.

      It should be a tensor of shape (N, D), where D is the number of joints and
      N is the batch size.


   .. py:attribute:: effort
      :type:  robo_orchard_core.utils.config.TorchTensor | None
      :value: None


      The effort/torque applied to the joint in Newton-meters or Newtons.

      It should be a tensor of shape (N, D), where D is the number of joints and
      N is the batch size.


   .. py:attribute:: names
      :type:  list[str] | None
      :value: None


      The names of the joints. The names are identical to the
      joint names in the robot description file (e.g., URDF or SDF).
      In this case, the name is also referred as frame_id.

      We recommand using the frame_id of the joint in the robot description
      file as the name. If the name and frame_id are not the same,
      use the name field from JointState message in ROS.

      The size of the names list should match the number of joints D.


   .. py:property:: batch_size
      :type: int


      Get the batch size of the joint state.


   .. py:method:: check_shape()


   .. py:method:: concat(others: Sequence[BatchJointsState], dim: int) -> BatchJointsState

      Concatenate two BatchJointsState objects along a given dimension.

      :param other: The other BatchJointsState
                    to concatenate.
      :type other: BatchJointsState
      :param dim: The dimension along which to concatenate. This can be
                  0 (batch dimension), -1 (joint dimension), or 1 (joint
                  dimension).
      :type dim: int

      :returns: A new BatchJointsState with concatenated data.
      :rtype: BatchJointsState



   .. py:attribute:: model_config

      Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].


   .. py:method:: model_post_init(*args, **kwargs)

      Post init method for the model.

      Perform additional initialization after :py:meth:`__init__`
      and model_construct. This is useful if you want to do some validation
      that requires the entire model to be initialized.

      To be consistent with configclass, this method is implemented by
      calling the :py:meth:`__post_init__` method.




   .. py:attribute:: model_fields
      :type:  ClassVar[dict[str, pydantic.fields.FieldInfo]]


   .. py:property:: model_extra
      :type: dict[str, Any] | None


      Get extra fields set during validation.

      :returns: A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.


   .. py:property:: model_fields_set
      :type: set[str]


      Returns the set of fields that have been explicitly set on this model instance.

      :returns:

                A set of strings representing the fields that have been set,
                    i.e. that were not filled from defaults.


   .. py:method:: model_construct(_fields_set: set[str] | None = None, **values: Any) -> typing_extensions.Self
      :classmethod:


      Creates a new instance of the `Model` class with validated data.

      Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
      Default values are respected, but no other validation is performed.

      !!! note
          `model_construct()` generally respects the `model_config.extra` setting on the provided model.
          That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`
          and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.
          Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in
          an error if extra values are passed, but they will be ignored.

      :param _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,
                          this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.
                          Otherwise, the field names from the `values` argument will be used.
      :param values: Trusted or pre-validated data dictionary.

      :returns: A new instance of the `Model` class with validated data.



   .. py:method:: model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -> typing_extensions.Self

      Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy

      Returns a copy of the model.

      :param update: Values to change/add in the new model. Note: the data is not validated
                     before creating the new model. You should trust this data.
      :param deep: Set to `True` to make a deep copy of the model.

      :returns: New model instance.



   .. py:method:: model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> dict[str, Any]

      Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump

      Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.

      :param mode: The mode in which `to_python` should run.
                   If mode is 'json', the output will only contain JSON serializable types.
                   If mode is 'python', the output may contain non-JSON-serializable Python objects.
      :param include: A set of fields to include in the output.
      :param exclude: A set of fields to exclude from the output.
      :param context: Additional context to pass to the serializer.
      :param by_alias: Whether to use the field's alias in the dictionary key if defined.
      :param exclude_unset: Whether to exclude fields that have not been explicitly set.
      :param exclude_defaults: Whether to exclude fields that are set to their default value.
      :param exclude_none: Whether to exclude fields that have a value of `None`.
      :param round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
      :param warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
                       "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
      :param serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.

      :returns: A dictionary representation of the model.



   .. py:method:: model_dump_json(*, indent: int | None = None, include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> str

      Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json

      Generates a JSON representation of the model using Pydantic's `to_json` method.

      :param indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
      :param include: Field(s) to include in the JSON output.
      :param exclude: Field(s) to exclude from the JSON output.
      :param context: Additional context to pass to the serializer.
      :param by_alias: Whether to serialize using field aliases.
      :param exclude_unset: Whether to exclude fields that have not been explicitly set.
      :param exclude_defaults: Whether to exclude fields that are set to their default value.
      :param exclude_none: Whether to exclude fields that have a value of `None`.
      :param round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
      :param warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
                       "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
      :param serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.

      :returns: A JSON string representation of the model.



   .. py:method:: model_json_schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, schema_generator: type[pydantic.json_schema.GenerateJsonSchema] = GenerateJsonSchema, mode: pydantic.json_schema.JsonSchemaMode = 'validation') -> dict[str, Any]
      :classmethod:


      Generates a JSON schema for a model class.

      :param by_alias: Whether to use attribute aliases or not.
      :param ref_template: The reference template.
      :param schema_generator: To override the logic used to generate the JSON schema, as a subclass of
                               `GenerateJsonSchema` with your desired modifications
      :param mode: The mode in which to generate the schema.

      :returns: The JSON schema for the given model class.



   .. py:method:: model_parametrized_name(params: tuple[type[Any], Ellipsis]) -> str
      :classmethod:


      Compute the class name for parametrizations of generic classes.

      This method can be overridden to achieve a custom naming scheme for generic BaseModels.

      :param params: Tuple of types of the class. Given a generic class
                     `Model` with 2 type variables and a concrete model `Model[str, int]`,
                     the value `(str, int)` would be passed to `params`.

      :returns: String representing the new class where `params` are passed to `cls` as type variables.

      :raises TypeError: Raised when trying to generate concrete names for non-generic models.



   .. py:method:: model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: pydantic._internal._namespace_utils.MappingNamespace | None = None) -> bool | None
      :classmethod:


      Try to rebuild the pydantic-core schema for the model.

      This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
      the initial attempt to build the schema, and automatic rebuilding fails.

      :param force: Whether to force the rebuilding of the model schema, defaults to `False`.
      :param raise_errors: Whether to raise errors, defaults to `True`.
      :param _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
      :param _types_namespace: The types namespace, defaults to `None`.

      :returns: Returns `None` if the schema is already "complete" and rebuilding was not required.
                If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.



   .. py:method:: model_validate(obj: Any, *, strict: bool | None = None, from_attributes: bool | None = None, context: Any | None = None) -> typing_extensions.Self
      :classmethod:


      Validate a pydantic model instance.

      :param obj: The object to validate.
      :param strict: Whether to enforce types strictly.
      :param from_attributes: Whether to extract data from object attributes.
      :param context: Additional context to pass to the validator.

      :raises ValidationError: If the object could not be validated.

      :returns: The validated model instance.



   .. py:method:: model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, context: Any | None = None) -> typing_extensions.Self
      :classmethod:


      Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing

      Validate the given JSON data against the Pydantic model.

      :param json_data: The JSON data to validate.
      :param strict: Whether to enforce types strictly.
      :param context: Extra variables to pass to the validator.

      :returns: The validated Pydantic model.

      :raises ValidationError: If `json_data` is not a JSON string or the object could not be validated.



   .. py:method:: model_validate_strings(obj: Any, *, strict: bool | None = None, context: Any | None = None) -> typing_extensions.Self
      :classmethod:


      Validate the given object with string data against the Pydantic model.

      :param obj: The object containing string data to validate.
      :param strict: Whether to enforce types strictly.
      :param context: Extra variables to pass to the validator.

      :returns: The validated Pydantic model.



   .. py:method:: dict(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -> Dict[str, Any]


   .. py:method:: json(*, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -> str


   .. py:method:: parse_obj(obj: Any) -> typing_extensions.Self
      :classmethod:



   .. py:method:: parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: pydantic.deprecated.parse.Protocol | None = None, allow_pickle: bool = False) -> typing_extensions.Self
      :classmethod:



   .. py:method:: parse_file(path: str | pathlib.Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: pydantic.deprecated.parse.Protocol | None = None, allow_pickle: bool = False) -> typing_extensions.Self
      :classmethod:



   .. py:method:: from_orm(obj: Any) -> typing_extensions.Self
      :classmethod:



   .. py:method:: construct(_fields_set: set[str] | None = None, **values: Any) -> typing_extensions.Self
      :classmethod:



   .. py:method:: copy(*, include: pydantic._internal._utils.AbstractSetIntStr | pydantic._internal._utils.MappingIntStrAny | None = None, exclude: pydantic._internal._utils.AbstractSetIntStr | pydantic._internal._utils.MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -> typing_extensions.Self

      Returns a copy of the model.

      !!! warning "Deprecated"
          This method is now deprecated; use `model_copy` instead.

      If you need `include` or `exclude`, use:

      ```python {test="skip" lint="skip"}
      data = self.model_dump(include=include, exclude=exclude, round_trip=True)
      data = {**data, **(update or {})}
      copied = self.model_validate(data)
      ```

      :param include: Optional set or mapping specifying which fields to include in the copied model.
      :param exclude: Optional set or mapping specifying which fields to exclude in the copied model.
      :param update: Optional dictionary of field-value pairs to override field values in the copied model.
      :param deep: If True, the values of fields that are Pydantic models will be deep-copied.

      :returns: A copy of the model with included, excluded and updated fields as specified.



   .. py:method:: schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE) -> Dict[str, Any]
      :classmethod:



   .. py:method:: schema_json(*, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any) -> str
      :classmethod:



   .. py:method:: validate(value: Any) -> typing_extensions.Self
      :classmethod:



   .. py:method:: update_forward_refs(**localns: Any) -> None
      :classmethod:



   .. py:method:: to(device: robo_orchard_core.utils.torch_utils.Device, dtype: torch.dtype | None = None, non_blocking: bool = False) -> typing_extensions.Self

      Move or cast the tensors/modules in the data class.

      This method performs in-place conversion of all tensors and modules
      in the data class to the specified device and dtype.

      :param device: The target device to move the tensors/modules to.
      :type device: Device
      :param dtype: The target dtype to cast
                    the tensors to. If None, the dtype will not be changed.
      :type dtype: torch.dtype | None, optional
      :param non_blocking: If True, the operation will be
                           performed in a non-blocking manner. Defaults to False.
      :type non_blocking: bool, optional



.. py:data:: ToBatchJointsState_SRC_TYPE

.. py:class:: ToBatchJointsState(cfg: ToBatchJointsStateConfig)

   Bases: :py:obj:`robo_orchard_lab.dataset.experimental.mcap.msg_converter.base.MessageConverterStateless`\ [\ :py:obj:`ToBatchJointsState_SRC_TYPE`\ , :py:obj:`BatchJointsStateStamped`\ ]


   Convert to BatchJointsStateStamped.

   This class accepts either a single `JointStateStamped` or
   `MultiJointStateStamped`, or a list of either type.
   The output is a `BatchJointsStateStamped` object containing
   the joint states in a batch format.



   .. py:method:: convert(src: ToBatchJointsState_SRC_TYPE) -> BatchJointsStateStamped

      Convert the message from one format to another.



   .. py:property:: stateless
      :type: bool


      Return True if the message converter is stateless.

      A message converter is stateless if it does not depend on any
      external state. For example, a message converter that converts a
      protobuf message to a json message is stateless.


   .. py:attribute:: source_type
      :type:  type[S]

      The source type of the adaptor to take as input.


   .. py:attribute:: target_type
      :type:  type[T]

      The target type of the adaptor as output.


   .. py:attribute:: InitFromConfig
      :type:  bool
      :value: True



.. py:class:: ToBatchJointsStateConfig

   Bases: :py:obj:`robo_orchard_lab.dataset.experimental.mcap.msg_converter.base.MessageConverterConfig`\ [\ :py:obj:`ToBatchJointsState`\ ], :py:obj:`robo_orchard_lab.dataset.experimental.mcap.msg_converter.base.TensorTargetConfigMixin`\ [\ :py:obj:`ToBatchJointsState`\ ]


   .. py:attribute:: class_type
      :type:  type[ToBatchJointsState]


